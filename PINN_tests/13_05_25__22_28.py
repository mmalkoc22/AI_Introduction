# -*- coding: utf-8 -*-
"""Ustalik.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eyD4fv8viV9SDnvLd5U1bMHjJZVxeZ13
"""

import pandas as pd
import torch
import numpy as np
import torch.nn as nn
from torch.utils.data import TensorDataset, DataLoader

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv('/content/drive/MyDrive/PINN_project/pinn_temperature_data.csv')

import pandas as pd
import numpy as np

data_frac = 0.01
data_df = df.sample(frac=data_frac, random_state=42).reset_index(drop=True)

x_min, x_max = df["x"].min(), df["x"].max()
t_min, t_max = df["t"].min(), df["t"].max()


n_colloc = 32_000

n_x = int(np.sqrt(n_colloc))
n_t = n_colloc // n_x

x_grid = np.linspace(x_min, x_max, n_x)
t_grid = np.linspace(t_min, t_max, n_t)

x_col, t_col = np.meshgrid(x_grid, t_grid, indexing="ij")
colloc_df = pd.DataFrame({
    "x": x_col.ravel(),
    "t": t_col.ravel()
})
# Burada T yok; PINN artık kaybında kullanılacak
#----------------------------------------
# 3. SINIR ve BAŞLANGIÇ NOKTALARI
#----------------------------------------
L = x_max            # sen 1 m kullanıyordun
boundary_df = df.query("x == 0 or x == @L")
initial_df  = df.query("t == 0")

#----------------------------------------
# 4. KULLANIMA HAZIR TENSÖRLER
#----------------------------------------
import torch

x_data  = torch.tensor(data_df["x"].values, dtype=torch.float32).unsqueeze(1)
t_data  = torch.tensor(data_df["t"].values, dtype=torch.float32).unsqueeze(1)
T_data  = torch.tensor(data_df["T"].values, dtype=torch.float32).unsqueeze(1)

x_colloc = torch.tensor(colloc_df["x"].values, dtype=torch.float32).unsqueeze(1)
t_colloc = torch.tensor(colloc_df["t"].values, dtype=torch.float32).unsqueeze(1)

x_bndry = torch.tensor(boundary_df["x"].values, dtype=torch.float32).unsqueeze(1)
t_bndry = torch.tensor(boundary_df["t"].values, dtype=torch.float32).unsqueeze(1)
T_bndry = torch.tensor(boundary_df["T"].values, dtype=torch.float32).unsqueeze(1)

x_init  = torch.tensor(initial_df["x"].values, dtype=torch.float32).unsqueeze(1)
t_init  = torch.tensor(initial_df["t"].values, dtype=torch.float32).unsqueeze(1)
T_init  = torch.tensor(initial_df["T"].values, dtype=torch.float32).unsqueeze(1)

# Artık PINN eğitim fonksiyonuna bu tensörleri veriyorsun.

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
x_data, t_data, T_data = [t.to(device) for t in (x_data, t_data, T_data)]
x_colloc, t_colloc = [t.to(device) for t in (x_colloc, t_colloc)]
x_init, t_init, T_init = [t.to(device) for t in (x_init, t_init, T_init)]

"""
pinn_model.py
-----------------
Pure network definition for a 1‑D transient heat‑conduction PINN.
*The surface heat‑flux parameter **q0** is **not** included as a trainable
parameter; it will be supplied externally during the loss computation.*
"""

from __future__ import annotations
import torch
import torch.nn as nn
from typing import Sequence


class PINN(nn.Module):
    """Fully‑connected ReLU network (no trainable q0)."""
    def __init__(self, layers: Sequence[int] = (2, 20, 20, 20, 1)) -> None:
        super().__init__()

        modules: list[nn.Module] = []
        for in_dim, out_dim in zip(layers[:-2], layers[1:-1]):
            modules.append(nn.Linear(in_dim, out_dim))
            modules.append(nn.ReLU())
        modules.append(nn.Linear(layers[-2], layers[-1]))

        self.net = nn.Sequential(*modules)

    def forward(self, x: torch.Tensor, t: torch.Tensor) -> torch.Tensor:  # (N,1) each
        """Predict temperature T(x, t)."""
        return self.net(torch.cat([x, t], dim=1))


# -----------------------------------------------------------------------------
# Data‑loss helper
# -----------------------------------------------------------------------------

def data_loss(model: PINN,
              x_data: torch.Tensor,
              t_data: torch.Tensor,
              T_data: torch.Tensor,
              *,
              reduction: str = "mean") -> torch.Tensor:
    """Mean‑squared error between model prediction and measured temperature."""
    pred = model(x_data, t_data)
    mse = (pred - T_data) ** 2
    return torch.mean(mse) if reduction == "mean" else torch.sum(mse)


# -----------------------------------------------------------------------------
# Simple *data‑only* training loop
# -----------------------------------------------------------------------------

def train_data_only(model: PINN,
                    x_data: torch.Tensor,
                    t_data: torch.Tensor,
                    T_data: torch.Tensor,
                    *,
                    epochs: int = 1000,
                    lr: float = 1e-3,
                    batch_size: Optional[int] = None,
                    use_amp: bool = True) -> None:
    """Train the network using **only** the data‑loss.

    Parameters
    ----------
    model      : the PINN instance (already on correct device)
    x_data/t_data/T_data : tensors of equal length N
    epochs     : number of passes over the full dataset
    lr         : Adam learning‑rate
    batch_size : mini‑batch size (default → full batch)
    use_amp    : enable mixed precision when CUDA is available
    """
    device = next(model.parameters()).device
    scaler = torch.cuda.amp.GradScaler(enabled=(device.type == "cuda" and use_amp))
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)

    N = x_data.shape[0]
    if batch_size is None or batch_size >= N:
        batch_size = N  # full batch

    for ep in range(1, epochs + 1):
        perm = torch.randperm(N, device=device)
        for start in range(0, N, batch_size):
            idx = perm[start:start + batch_size]
            loss = data_loss(model, x_data[idx], t_data[idx], T_data[idx])

            optimizer.zero_grad(set_to_none=True)
            if scaler.is_enabled():
                with torch.cuda.amp.autocast():
                    scaler.scale(loss).backward()
                scaler.step(optimizer)
                scaler.update()
            else:
                loss.backward()
                optimizer.step()

        # --- logging ---
        if ep % 50 == 0 or ep == 1:
            print(f"ep {ep:5d} | data‑loss {loss.item():.4e}")

# ------------------------------------------------------------------
model = PINN().to(device)

# ------------------------------------------------------------------
# 3) Sadece data-loss ile eğit
# ------------------------------------------------------------------
train_data_only(
    model,
    x_data, t_data, T_data,
    epochs=2000,        # ihtiyacına göre
    lr=1e-3,            # başlangıç öğrenme oranı
    batch_size=64,     # VRAM uygunsa mini-batch
    use_amp=True        # CUDA varsa otomatik yarım hassasiyet
)

import torch
import matplotlib.pyplot as plt
import numpy as np

# ------------------------------------------------------------------
# Assumptions:
# - `model`, `x_data`, `t_data`, `T_data` are already defined in the
#   current Python session (they come from your training script).
# - All tensors are on the same device as the model.
# ------------------------------------------------------------------

device = next(model.parameters()).device

# Ensure tensors are on the same device
x_data = x_data.to(device)
t_data = t_data.to(device)

# 1) Create a regular (x, t) grid covering the data range
n = 1000  # resolution of the heatmap
x_lin = torch.linspace(x_data.min(), x_data.max(), n, device=device).unsqueeze(1)
t_lin = torch.linspace(t_data.min(), t_data.max(), n, device=device).unsqueeze(1)
Xg, Tg = torch.meshgrid(x_lin.squeeze(), t_lin.squeeze(), indexing="ij")

# Flatten grid for batch prediction
X_in = Xg.reshape(-1, 1)
T_in = Tg.reshape(-1, 1)

# 2) Predict temperature field without tracking gradients
model.eval()
with torch.no_grad():
    preds = model(X_in, T_in).cpu().numpy().reshape(n, n)

# 3) Plot heatmap of predicted temperature
plt.figure(figsize=(6, 4))
plt.imshow(
    preds,
    origin="lower",
    aspect="auto",
    extent=[t_lin.min().cpu(),t_lin.max().cpu(), x_lin.min().cpu(), x_lin.max().cpu()],cmap='hot'
)
plt.xlabel("t (s)")
plt.ylabel("x (m)")
plt.title("Predicted Temperature Field")
plt.colorbar(label="T")
plt.tight_layout()
plt.show()

# Örnek: tek nokta (x=0.15 m, t=1800 s)
x_val = 0.15
t_val = 7200.0

# 1) NumPy → torch.Tensor  ve boyut (N,1)
x_in = torch.tensor([[x_val]], dtype=torch.float32)
t_in = torch.tensor([[t_val]], dtype=torch.float32)

# 2) Eğitimde -1…1 ölçeklediysen aynı dönüşümü UYGULA
# x_in = 2*(x_in - x_min)/(x_max - x_min) - 1
# t_in = 2*(t_in - t_min)/(t_max - t_min) - 1

# 3) Modele ve tensörlere aynı cihaz
device = next(model.parameters()).device
x_in, t_in = x_in.to(device), t_in.to(device)

# 4) Tahmin (gradients kapalı)
model.eval()
with torch.no_grad():
    T_pred = model(x_in, t_in)      # (1,1) tensör
print("Tahmin edilen sıcaklık:", T_pred.item())

